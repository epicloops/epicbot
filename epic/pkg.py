'''
Downloads, packages, and uploads the results of epicbot and epicsampler.
'''
import os
import shutil
import logging
import zipfile

import boto
from boto import s3

from sqlalchemy import select
from sqlalchemy.sql import and_

from epic.models import session, Tracks


log = logging.getLogger(__name__)


ECHONEST_KEYS = [
    'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B',
]

ECHONEST_MODES = ['Major', 'Minor']


def _crawl_id_from_key(key):
    '''Return crawl_id from s3 key.

    :param key: s3 key.
    '''
    return key.name.split('/')[3]

def _download_file(dl_dir, key):
    '''Download s3 keys to dl_dir.

    :param dl_dir: Directory to download files to.
    :param key: s3 key to download.
    '''
    fname = os.path.join(dl_dir, os.path.basename(key.name))
    if not os.path.exists(dl_dir):
        os.makedirs(dl_dir)
    key.get_contents_to_filename(fname)
    return fname

def _get_s3_conn():
    return boto.connect_s3(os.environ.get('AWS_ACCESS_KEY_ID'),
                           os.environ.get('AWS_SECRET_ACCESS_KEY'))

def _write(fname, data):
    path = os.path.dirname(fname)
    if not os.path.exists(path):
        os.makedirs(path)

    with open(fname, 'w') as f:
        f.write('\n'.join(data))

    return fname

def _write_license(path, track):
    license_txt = [
        'ARTIST: {track[artist]}'.format(track=track),
        'ARTIST URL: {track[artist_url]}'.format(track=track),
        'TRACK TITLE: {track[title]}'.format(track=track),
        'TRACK URL: {track[track_url]}'.format(track=track),
        'LICENSE URL: {track[license_url]}'.format(track=track),
    ]
    return _write(os.path.join(path, 'LICENSE.txt'), license_txt)

def _write_profile(path, track):
    profile_txt = [
        'TEMPO: {track[echonest_tempo]} BPM'.format(track=track),

        'TEMPO CONFIDENCE: '
        '{track[echonest_tempo_confidence]}'.format(track=track),

        'KEY: {}'.format(ECHONEST_KEYS[int(track['echonest_key'])]),

        'KEY CONFIDENCE: '
        '{track[echonest_key_confidence]} BPM'.format(track=track),

        'MODE: {}'.format(ECHONEST_MODES[int(track['echonest_mode'])]),

        'MODE CONFIDENCE: '
        '{track[echonest_mode_confidence]} BPM'.format(track=track),

        'TIME SIGNATURE: {track[echonest_time_signature]} '
        'beats/measure'.format(track=track),

        'TIME SIGNATURE CONFIDENCE: '
        '{track[echonest_time_signature_confidence]}'.format(track=track),
    ]
    return _write(os.path.join(path, 'PROFILE.txt'), profile_txt)

def _write_manifest(path, sample_type, samples):
    manifest = []
    if sample_type == 'sections':
        for sample in samples:

            entry = [
                '{sample[sample_num]:04d}.mp3'.format(sample=sample),

                '  - SECTION CONFIDENCE: '
                '{sample[confidence]}'.format(sample=sample),

                '  - TEMPO: {sample[tempo]} BPM'.format(sample=sample),

                '  - TEMPO CONFIDENCE: '
                '{sample[tempo_confidence]}'.format(sample=sample),

                '  - KEY: {}'.format(ECHONEST_KEYS[int(sample['key'])]),

                '  - KEY CONFIDENCE: '
                '{sample[key_confidence]}'.format(sample=sample),

                '  - MODE: {}'.format(ECHONEST_MODES[int(sample['mode'])]),

                '  - MODE CONFIDENCE: '
                '{sample[mode_confidence]}'.format(sample=sample),

                '  - TIME SIGNATURE: {sample[time_signature]} '
                'beats/measure'.format(sample=sample),

                '  - TIME SIGNATURE CONFIDENCE: '
                '{sample[time_signature_confidence]}'.format(sample=sample),
            ]

            manifest += entry
    else:
        manifest += ['FILENAME: CONFIDENCE']
        for sample in samples:
            manifest.append('{sample[sample_num]:04d}.mp3: '
                            '{sample[confidence]}'.format(sample=sample))

    return _write(os.path.join(path, sample_type, '0000_MANIFEST.txt'),
                  manifest)

def download(filename, bot_bucket, sampler_bucket, spider, crawl_start,
              sampler_start, dl_samples, *args, **kwargs):
    '''Download tracks and samples generated by epicbot and epicsampler.

    :param filename: Relative path from cwd to file containing crawl_ids to dl.
    :param bot_bucket: Name of s3 bucket where epicbot results are stored.
    :param sampler_bucket: Name of s3 bucket where epicsampler results are stored.
    :param spider: Epicbot spider to process.
    :param crawl_start: Start timestamp from epicbot crawl to process.
    :param sampler_start: Start timestamp from epicsampler run to process.
    :param dl_samples: Flag to prevent samples from being downloaded.
    '''
    fp = os.path.join(os.getcwd(), filename)
    cids = [cid for cid in open(fp).read().splitlines() if cid]

    dl_dir = os.path.join(os.getcwd(), 'dl', os.path.splitext(filename)[0])

    if os.path.exists(dl_dir):
        shutil.rmtree(dl_dir)
    os.makedirs(dl_dir)

    conn = _get_s3_conn()
    bot_bkt = s3.bucket.Bucket(conn, bot_bucket)
    smp_bkt = s3.bucket.Bucket(conn, sampler_bucket)

    # download full tracks
    s3_data_dir = '/'.join([crawl_start, spider, 'data/'])
    tracks_all = (k for k in bot_bkt.list(s3_data_dir))
    _tracks = (k for k in tracks_all if _crawl_id_from_key(k) in cids)

    for k in _tracks:
        cid_dir = os.path.join(dl_dir, _crawl_id_from_key(k))
        fname = _download_file(cid_dir, k)
        log.info('Downloaded: %s to %s', k, fname)

    # download samples
    if dl_samples:
        s3_sampler_dir = '/'.join([crawl_start, spider, sampler_start])
        samples = (k for k in smp_bkt.list(s3_sampler_dir) if _crawl_id_from_key(k) in cids)
        for k in samples:
            sample_dir = os.path.join(dl_dir, _crawl_id_from_key(k),
                                k.name.split('/')[4])
            fname = _download_file(sample_dir, k)
            log.info('Downloaded: %s to %s', k, fname)

def build(dl_dir, crawl_start, *args, **kwargs):
    '''Build contents of pkg directory to be zipped and uploaded.

    Copy downloaded files to pkg dir. Generate license, profile, and manifest
    files.

    :param dl_dir: Directory, relative to cwd, containing tracks and samples.
    :param crawl_start: Start timestamp from epicbot crawl to process.
    '''
    pkg_dir = os.path.join(os.getcwd(), 'pkg',
                           os.path.basename(os.path.abspath(dl_dir)))

    if os.path.exists(pkg_dir):
        shutil.rmtree(pkg_dir)
        log.info('Removed: %s', pkg_dir)
    shutil.copytree(dl_dir, pkg_dir)
    log.info('Copied: %s to %s', dl_dir, pkg_dir)

    conn = engine.connect()

    cids = os.listdir(dl_dir)
    for i, cid in enumerate(cids):
        cid_dir = os.path.join(pkg_dir, cid)

        track = conn.execute(
            select([tracks]).where(
                and_(
                    tracks.c.crawl_key == cid,
                    tracks.c.crawl_start == crawl_start
                )
            )
        ).fetchone()

        fname = _write_license(cid_dir, track)
        log.info('Created: %s', fname)
        fname = _write_profile(cid_dir, track)
        log.info('Created: %s', fname)

        sample_types = ('sections', 'bars', 'beats', 'tatums', 'segments')
        sample_dirs = set(os.listdir(cid_dir)).intersection(set(sample_types))
        for sample_type in sample_dirs:
            table = metadata.tables[sample_type]
            samples = conn.execute(
                select([table]).where(
                    and_(
                        table.c.crawl_key == cid,
                        table.c.crawl_start == crawl_start
                    )
                )
            )
            fname = _write_manifest(cid_dir, str(table), samples)
            log.info('Created: %s', fname)

        # rename cid_dir from hash to friendlier number
        dst = os.path.join(pkg_dir, '{:02d}'.format(i))
        os.rename(cid_dir, dst)
        log.info('Renamed: %s to %s', cid_dir, dst)

    return pkg_dir

def zip_(pkg_dir, *args, **kwargs):
    '''Zip the contents of the pkg directory.

    :param pkg_dir: Directory, relative to cwd, to zip.
    '''
    zip_fname = '{}.zip'.format(pkg_dir)
    zipf = zipfile.ZipFile(zip_fname, 'w')
    for root, _, files in os.walk(pkg_dir):
        for f in files:
            fname = os.path.join(root, f)
            rel_fname = os.path.relpath(fname, pkg_dir)
            zipf.write(fname, zip_fname)
            log.info('Zipped: %s as %s', fname, rel_fname)
    zipf.close()
    return zip_fname

def upload(pkg_bucket, zip_fname, clean, *args, **kwargs):
    '''Upload zip to s3.

    :param pkg_bucket: s3 bucket where zip will be uploaded.
    :param zip_fname: Filename of zip to upload.
    :param clean: Flag to remove pkg dir after uplaod.
    '''
    conn = _get_s3_conn()
    bucket = s3.bucket.Bucket(conn, pkg_bucket)
    k = s3.key.Key(bucket, os.path.basename(zip_fname))
    k.set_contents_from_filename(zip_fname)
    log.info('Uploaded: %s to %s', zip_fname, k)
    k.close()
    if clean:
        shutil.rmtree('pkg')
        log.info('Removed: pkg')


def pkg(dl_dir, pkg_bucket, crawl_start, clean, *args, **kwargs):
    '''A convenience function to build, zip, and upload all at once.

    :param dl_dir: Directory, relative to cwd, containing tracks and samples.
    :param pkg_bucket: s3 bucket where zip will be uploaded.
    :param crawl_start: Start timestamp from epicbot crawl to process.
    :param clean: Flag to remove pkg dir after uplaod.
    '''
    pkg_dir = build(dl_dir, crawl_start, *args, **kwargs)
    zip_fname = zip_(pkg_dir, *args, **kwargs)
    upload(pkg_bucket, zip_fname, clean, *args, **kwargs)
